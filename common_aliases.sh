# makes aliases work with sudo
alias sudo='sudo '

# editor
alias edit=notepadqq

# explorer
alias explorer=pcmanfm

# clear
alias cls=clear

# ls aliases
alias ll='ls -l'
alias lla='ls -al'
alias la='ls -a'
alias l='ls'
# TODO: ls -R | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\// /g' -e 's/^/ /'
# TODO: tree

# cd aliases
alias cd..='cd ..'
alias cd-='cd -'
alias cd~='cd ~'

alias .-='cd -'

alias cd1='cd ..'
alias ..='cd ..'
alias .1='cd ..'

alias cd2='cd ../..'
alias .2='cd ../..'
alias ...='cd ../..'

alias cd3='cd ../../..'
alias .3='cd ../../..'
alias ....='cd ../../..'

alias cd4='cd ../../../..'
alias .4='cd ../../../..'
alias .....='cd ../../../..'


alias cd5='cd ../../../../..'
alias .5='cd ../../../../..'
alias ......='cd ../../../../..'

alias cd6='cd ../../../../../..'
alias .6='cd ../../../../../..'
alias .......='cd ../../../../../..'

alias cd7='cd ../../../../../../..'
alias .7='cd ../../../../../../..'
alias ........='cd ../../../../../../..'

alias cd8='cd ../../../../../../../..'
alias .8='cd ../../../../../../../..'
alias .........='cd ../../../../../../../..'

alias cd9='cd ../../../../../../../../..'
alias .9='cd ../../../../../../../../..'
alias ..........='cd ../../../../../../../../..'

# package tool aliases ('s' stands for system - running with sudo)
alias supdate='sudo apt update && sudo apt upgrade'
alias supdate-dist='sudo apt dist-upgrade'
alias supdate-get='sudo apt update'
alias supdate-list='sudo apt list --upgradable'

alias sinstall='sudo apt install'
alias sinstall-snap='sudo snap install'
alias sinstall-snap-cl='sudo snap install --classic'

alias sremove='sudo apt remove'
alias sremove-all='sudo apt remove --purge'
alias sremove-auto='sudo apt autoremove'

alias srepadd='sudo add-apt-repository'
alias srepremove='audo add-apt-repository -r'
alias slist='sudo apt list --installed'

# systemctl deamon service aliases
alias sdaamon='systemctl'
alias sdaemon-status='systemctl status'
alias sdaemon-stop='systemctl stop'
alias sdaemon-restart='systemctl restart'
alias sdaemon-enable='systemctl enable'
alias sdaemon-disable='systemctl disable'

# ps aliases
alias psgrep='ps aux | grep'

# df aliases
alias df='df -T'
alias dfh='df -h'

# network
alias ports='netstat -tulanp'
alias ping='ping -c 5'
alias wget='wget -c'
alias top='atop'

# exit aliases
alias :q='exit'
alias quit='exit'

# change ownership/permissions
alias chown-root='chown root:root'
alias chown-me='sudo chown $USER:$USER'
alias chmod-exe='chmod a+x'

# java aliases
alias javar='java -jar'

# cmake aliases
alias cmake-release='cmake -DCMAKE_BUILD_TYPE=Release'
alias cmake-debug='cmake -DCMAKE_BUILD_TYPE=Debug'

# Add an 'alert' aliast for long running commands. Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# fix alias autocompletion

# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
${wrapper_name}() {
  let COMP_CWORD+=$num_alias_arguments
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}

# For each defined alias, extract the necessary elements and use them
# to call wrap_alias.
# TODO: fix for sudo
eval "$(alias -p | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/wrap_alias \1 \2 '\''\3'\'' /')"
unset wrap_alias